//
// File: Reconstructor.cxx
//
// Author: Hunter Sullivan
//
// Description: Structure to run reconstruction on sipm data.
//

#include "Reconstructor.h"

namespace majorana
{

Reconstructor::Reconstructor(const std::map<unsigned, unsigned>& data,
                             const std::list<Voxel>& voxelList)
: m_data(data),
  m_voxelList(voxelList)
{
  m_voxelEstimates.clear();
}

Reconstructor::~Reconstructor()
{}

void Reconstructor::Reconstruct()
{
  // The procedure:
  //
  //   1) Make initial estimates for voxel intensities
  //   2) Make next prediction
  //   3) Check for convergence
  //        *if yes, save, return
  //        *if not, initial estimates = current estimates -> 2)
  //

  // 1)
  Initialize();
  // 2)
  unsigned iteration(0);
  Estimate(iteration);
 
  // We should have the ml now
  std::cout << "Max log likelihood = " << m_mlLogLikelihood << std::endl
            << "X                  = " << m_mlX             << " cm\n"
            << "Y                  = " << m_mlY             << " cm\n"
            << "Radius             = " << m_mlRadius        << " cm\n"
            << "Theta              = " << m_mlTheta         << " deg\n" 
            << "N0                 = " << m_mlN0            << " photons\n";
}

void Reconstructor::Initialize()
{

}

void Reconstructor::Estimate(unsigned& iteration)
{
  iteration++;

  for (auto& voxel : m_voxelList)
  {
    // voxelID
    unsigned voxelID = voxel.ID();
    float    theEst  = voxel.Intensity(); 
    std::map<unsigned, float> opRefTable = voxel.ReferenceTable(); 

    // Apply the money formula
    float nextEst = MoneyFormula(voxelID, theEst, opRefTable);
    m_voxelEstimates.emplace(voxelID, nextEst);
  }

  // 3) 
  bool didConverge = CheckConvergance();
  if (!didConverge) 
  {
    Reset();
    Estimate(iteration);
  }
}

void Reconstructor::Reset()
{
  // Update the intensities
  for (auto& v : m_voxelList)
  {
    unsigned id = v.ID();
    float nextEst = m_voxelEstimates.find(id)->second;
    v.SetIntensity(nextEst);
  }
  m_voxelEstimates.clear();
}

float Reconstructor::MoneyFormula(const unsigned& voxelID, 
                                  const float&    theEst,
                                  std::map<unsigned, unsigned>& opRefTable)
{
  // Looping over detectors
  float sum(0);
  float totalP(0);
  for (const auto& d : data)
  {
    // n p.e. and ref table
    unsigned n = d.second;
    float p(0);
    auto it = opRefTable.find(d.first);
    if (it == opRefTable.end())
    {
      std::cerr << "Uh oh! Could not find MPPC" << d.first << " in reference table! << std::endl;
    }
    else p = it->second;

    // Add to totalP
    totalP = totalP + p;

    // Apply sum in denominator
    float denomSum = DenominatorSum(d.first);    
    sum = sum + n*p/denomSum;
  }

  return theEst*sum/totalP;
}

float Reconstructor::DenominatorSum(const unsigned& mppcID)
{
  // Loop over voxels
  for (const auto& voxel : m_voxelList)
  {
    float theEst = voxel.Intensity();
    float p(0);
    auto  it = voxel.ReferenceTable()->find(mppcID);
    if (it == opRefTable.end())
    {
      std::cerr << "Uh oh! Could not find MPPC" 
                << mppcID << " in reference table! << std::endl;
    }
    else p = thisIt->second;

    denomSum = denomSum + theEst*p;
  }
  return denomSum;
}

double Reconstructor::ComputeLogLikelihood(const float& x, const float& y, const unsigned& N0)
{
  // Convert x and y to polar coordinates 
  float r(0);
  float thetaDeg(0);
  ConvertToPolar(r, thetaDeg, x, y);  

  // Sum over terms ----> k_m*ln(lambda_m) - lambda_m - ln(k_m!)
  double sum = 0;
  for (int sipm = 1; sipm <= m_nSiPMs; sipm++) 
  {
    float    lambda_m = ComputeLambda(r, thetaDeg, N0, sipm);
    unsigned k_m      = m_data.find(sipm)->second;
 
    // Since we may be dealing with large numbers here, we need to handle the factorial carefully
    double term = k_m*std::log(lambda_m) - lambda_m - ComputeLogFactorial(k_m);
    sum = sum + term;
  }
  if (sum > 0) std::cout << "Ahh\n";

  return sum;
}

double Reconstructor::ComputeLogFactorial(const unsigned& counts)
{
  float sum(0);
  for (unsigned n = 1; n <= counts; n++)
  {
    sum = sum + std::log(n);
  }
  return sum;
}

void Reconstructor::ConvertToPolar(float& r, float& thetaDeg, const float& x, const float& y)
{
  r        = std::sqrt(x*x + y*y);
  thetaDeg = TMath::ASin(std::abs(y/r))*180/TMath::Pi();

  // Handle theta convention
  if (x < 0 && y > 0) thetaDeg = 180 - thetaDeg;
  if (x < 0 && y < 0) thetaDeg = 180 + thetaDeg;
  if (x > 0 && y < 0) thetaDeg = 360 - thetaDeg;
}

void Reconstructor::MakePlot(const unsigned& trigger)
{
  TFile f(m_recoOutputPath.c_str(), "UPDATE");

  // Log Likelihood distribution for m_mlN0
  TH2D logLikelihoodDist("logLikelihoodDist", "Likelihood Profile", 500, -m_diskRadius - 1, m_diskRadius + 1, 500, -m_diskRadius - 1, m_diskRadius + 1); 
  // Make a copy for contours
  auto contour68 = logLikelihoodDist;

  for (unsigned xBin = 1; xBin <= contour68.GetXaxis()->GetNbins(); xBin++)
  {
    for (unsigned yBin = 1; yBin <= contour68.GetYaxis()->GetNbins(); yBin++)
    {
      // Log likelihood for this parameter set
      float x(logLikelihoodDist.GetXaxis()->GetBinCenter(xBin));
      float y(logLikelihoodDist.GetYaxis()->GetBinCenter(yBin));
      double logLikelihood = ComputeLogLikelihood(x, y, m_mlN0);

      float r(0), theta(0);
      ConvertToPolar(r, theta, x, y);

      float diff = -2*(logLikelihood - m_mlLogLikelihood);

      // For plotting purposes
      if (diff > 10.0) diff = 10;  
      if (r > m_diskRadius) diff = 0;
      logLikelihoodDist.SetBinContent(xBin, yBin, diff);
      if (r > (m_diskRadius - 0.5)) diff = 10;
      contour68.SetBinContent(xBin, yBin, diff);
    }
  }  
  
  // Make copies to draw our contours
  auto contour90 = contour68;
  auto contour95 = contour68;

  // Set the confidence levels
  Double_t level68[1], level90[1], level95[1];
  level68[0] = TMath::ChisquareQuantile(0.68,3); // We had 3 d.o.f
  level90[0] = TMath::ChisquareQuantile(0.90,3);
  level95[0] = TMath::ChisquareQuantile(0.95,3);
  contour68.SetContour(1, level68);
  contour90.SetContour(1, level90);
  contour95.SetContour(1, level95);

  // Now draw the distribution and confidence regions
  std::string name1 = "logLikelihood_CL_" + std::to_string(trigger);
  TCanvas c1(name1.c_str(), name1.c_str(), 800, 800);
  logLikelihoodDist.Draw("colz");

  contour68.SetLineWidth(5);
  contour90.SetLineWidth(5);
  contour95.SetLineWidth(5);
  contour68.SetLineColor(4);
  contour90.SetLineColor(2);
  contour95.SetLineColor(3);
  contour68.Draw("cont3 same");
  contour90.Draw("cont3 same");
  contour95.Draw("cont3 same");

  // Add a marker for the MLE
  TMarker xy(m_mlX, m_mlY, 20);
  xy.SetMarkerSize(2);
  xy.SetMarkerColor(1);
  xy.Draw("same"); 

  TMarker trueXY(0.5, 10, 20);
  trueXY.SetMarkerSize(2);
  trueXY.SetMarkerColor(2);
  trueXY.Draw("same");
 
  // Add our legend
  TLegend leg1(0.1,0.6,0.3,0.7); 
  leg1.AddEntry(&contour68, "68% CL", "l");
  leg1.AddEntry(&contour90, "90% CL", "l"); 
  leg1.AddEntry(&contour95, "95% CL", "l"); 
  leg1.AddEntry(&xy, "MLE Position", "p");
  leg1.Draw("same");
  gStyle->SetPalette(53);
  TColor::InvertPalette();
  c1.Modified();

  c1.Update();
  c1.Write(); 

  // Make the comparison plot 
  std::string name2 = "data_mle_trigger" + std::to_string(trigger);
  TCanvas c2(name2.c_str(), name2.c_str(), 1000, 1000);
  // Get the counts lambda_m using the mlestimates for r, theta, and N0
  std::vector<unsigned> prediction;
  prediction.reserve(m_nSiPMs);
  // Maximum, used for plotting
  float max(0);
  for (const auto& d : m_data) if (d.second > max) max = d.second;
  for (int sipm = 1; sipm <= m_nSiPMs; sipm++) 
  {
    float lambda = ComputeLambda(m_mlRadius, m_mlTheta, m_mlN0, sipm); 
    prediction[sipm - 1] = static_cast<unsigned>(lambda);
    if (prediction[sipm - 1] > max) max = prediction[sipm - 1];
  }

  name2 = "pred_trigger" + std::to_string(trigger);
  TH1D pred(name2.c_str(), name2.c_str(), m_nSiPMs, 0, m_nSiPMs); 
  for (int posBin = 1; posBin <= m_nSiPMs; posBin++) pred.SetBinContent( posBin, prediction[posBin - 1] );
  
  pred.SetFillStyle(3001);
  pred.SetFillColor(kRed);
  pred.SetLineWidth(3);
  pred.SetLineColor(kRed);
  pred.GetXaxis()->SetTitle("SiPM Position");
  pred.GetYaxis()->SetTitle("p.e");
  pred.SetTitle("Estimator for SiPM Wheel");
  gStyle->SetOptStat(0);
  pred.SetMaximum(max+1);
  pred.SetMinimum(0);
  pred.Draw();

  name2 = "dataHisto_trigger" + std::to_string(trigger);
  TH1D dataHisto(name2.c_str(), name2.c_str(), m_nSiPMs, 0, m_nSiPMs);
  std::cout << "\nBin comparison:\n";
  for (int posBin = 1; posBin <= m_nSiPMs; posBin++) 
  {
    std::cout << "Data Bin " << posBin << " :  " << m_data.find(posBin)->second << " p.e." << "   Pred Bin " << posBin << " :  " << prediction[posBin - 1] << " p.e." << std::endl;
    dataHisto.SetBinContent(posBin, m_data.find(posBin)->second);
  }
  dataHisto.SetMarkerStyle(21);
  dataHisto.SetMarkerSize(2);
  dataHisto.Draw("same P");

  TLegend leg2(0.1,0.6,0.3,0.7);
  leg2.AddEntry(&pred, "Estimator", "f");
  leg2.AddEntry(&dataHisto, "Data", "p");

  c2.Write();
 
  f.Close();
}
}

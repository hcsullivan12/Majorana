//// Created by ilker on 3/27/20.//#ifndef ANA_CFUNCTIONS_H#define ANA_CFUNCTIONS_H#include <cmath>#include <stdio.h>#include <TTree.h>#include <TFile.h>#include "TH1F.h"#include "TH2.h"#include "TF2.h"#include "TMultiGraph.h"#include "TLegend.h"#include "TPaveLabel.h"#include "TCanvas.h"#include "TStyle.h"#include "TGraph.h"#include "TGraphQQ.h"#include "TRatioPlot.h"#include <iostream>#include <fstream>#include <string>#include <boost/algorithm/string.hpp>#include "TTreeHelp.h"#include "majreco/RecoAnalyzer.h"#include "majreco/Reconstructor.h"#include "majreco/Configuration.h"#include "majutil/PixelTable.h"using namespace std;namespace majutil{class Cfunctions {    public:        //Define Needed Variables        string Title;        TFile * f;        string FileName;        string TrueFilePath="None";        string FilePath;        float    Radius;        Double_t dif = 10;        Double_t TrueX;        Double_t TrueY;        Double_t ExpX;        Double_t ExpY;        // Define Histograms        TH1I *Measured;        TH1F *hDataMeasured= nullptr;        TH2F *hchi2D;        TH2F *hmli2D;        int EventID=0;        int SimEvents;        bool CDraw=false;        bool SaveImg=false;        bool SaveFile=false;        bool Skip=true;        std::string RecoDataFilePath;        std::string DeadChannelPath;        std::vector<unsigned> DeadChannels;        TFile *r;        majreco::RecoAnalyzer * ana;        int nPrimaries;        int nPixels;        int TotalSimLight;        std::vector<float>*sourcePosXYZ;        std::vector<int>*sipmToLY;        std::vector<float> SimReco;        std::vector<float> vTruePos;        std::vector<float> DataRecoPos;        TH1F * DataX;        TH1F * DataY;        TH1F*  SimX;        TH1F*  SimY;        TGraph * Chi2Residues= nullptr;        TH1F* Prob;        TH1F *SimData= nullptr;        TH1F *SimDataClone= nullptr;        TH1F *KolmSmir=nullptr;        int CountS=0;        int CountNS=0;        int CountEvents;        TGraphQQ * QGraph= nullptr;        TF1* Qv= nullptr;        TCanvas *mc1;//Combined TCanvas        std::vector<TH1F*> SIPMs;        float perc=0;        Long64_t SimTotalEvents;        Double_t CurrentEvent;        const Double_t * KSimData=nullptr;        const Double_t* KData=nullptr;        TH1F * TestData=nullptr;        TH1F * TestSim =nullptr;        std::vector<float> Gains;        int NSIPMs;        // Define Reconstructing Data        int ConfigUnpanilized=0;        majutil::PixelTable* PixelTable;        int DataEvents=0;        TH1F * hChi2Test;        TH1F * hChi2ProbTest;        TH1F * hKolTest;        //Define fits        TF2* SimGausFit=nullptr;        TF2* DataGausFit=nullptr;        double DataExpX;        double DataExpY;        bool Constrain=false;        // For Cuts        TH1F * TotalPEData;        TH1F * TotalPESim;        TH1F * TotalPERatiDataSIM;        TH1F * TotalPEData_Noise;        TH1F * TotalPERatiDataSIM_Noise;        TH1F * hGoodETime;        TH1F * hNoiseETime;        float NotCount=0;        float fDataErrX=-99999;        float fDataErrY=-99999;        majreco::Reconstructor *fSimReco;        unsigned dTime;    //Template for Saved Reconstructed Tree    struct RecoTTreeHelp{        vector<double>AnaExpY;        vector<double>AnaExpX;        vector<double>AnaErrX;        vector<double>AnaErrY;        vector<double>ActExpY;        vector<double>ActExpX;        vector<double>ActErrX;        vector<double>ActErrY;        vector<double>FiltExpY;        vector<double>FiltExpX;        vector<double>FiltErrX;        vector<double>FiltErrY;        vector<double>NPairExpY;        vector<double>NPairExpX;        vector<double>NPairErrX;        vector<double>NPairErrY;    };    //Destroy All     ~Cfunctions()    {        //DeleteAll();        //r->Clear();    }    //Reading the Dead Channels for MotherShip    void DeadChs (std::vector<unsigned> &Dead)    {        std::ifstream file(DeadChannelPath);        std::string str;        while (std::getline(file,str)) {            Dead.push_back(std::stoi(str));            std::cout<< "DeadChannels -> " + str<< std::endl;        }        if(Dead.size()>0)            std::cout<<"Dead SIPM are obtained from the file"<<std::endl;    }    //Creates or Updates and Fills given Tree    void CreateTree(RecoTTreeHelp *htr)    {        TTree* t = (TTree*)f->Get("reco");        if (!t)        {            t = new TTree("reco", "reco");            t->Branch("Histos",&htr);        }        else            t->SetBranchAddress("Histos",&htr);        t->Fill();        t->Write(t->GetName(), TObject::kWriteDelete);        t->Reset();    }    //Draw Circle and CombinedTCanvas in here    void DrawCircle(){            TGraph *TruePos = new TGraph(1);            TGraph *ExpPos = new TGraph(1);            TGraph *gr;            TMultiGraph *mg= new TMultiGraph();            if(!f) return;            Int_t n = 360;            Double_t x, y;            string sdev;            Double_t pR = Radius + dif;            Double_t nR = -Radius - dif;            vector<string> Error;            string ErrX;            string ErrY;            Error=ErroEst();            ErrX="ErrX= " + (Error[0]) ;            ErrY="ErrY= " + (Error[1])  ;            TCanvas *c1 = new TCanvas(Title.c_str(),Title.c_str(), 800, 800);            c1->SetGrid();            //Draw The circle            gr = new TGraph(n);            gr->SetMarkerColor(kBlack);            gr->SetMarkerStyle(21);            gr->SetLineWidth(1);            gr->SetMarkerSize(1);            TruePos->SetMarkerColor(kGreen);            TruePos->SetMarkerStyle(20);            TruePos->SetMarkerSize(2);            ExpPos->SetMarkerColor(kRed);            ExpPos->SetMarkerStyle(20);            ExpPos->SetMarkerSize(2);            for (Int_t i = 0; i < n; i++) {                x = Radius * cos(i);                y = Radius * sin(i);                gr->SetPoint(i, x, y);            }            TruePos->SetPoint(0,TrueX,TrueY);            ExpPos->SetPoint(0,ExpX, ExpY);            string TrueLabel;            string ExpLabel;            TrueLabel = "TrueX= " + to_string(TrueX) + " , " + "TrueY= " + to_string(TrueY);            ExpLabel = "ExpX= " + to_string(ExpX) + " , " + "ExpY= " + to_string(ExpY);            TLegend *leg;            leg = new TLegend(0.1,0.75,0.9,0.9);            leg->SetHeader("Results");            leg->AddEntry(TruePos, TrueLabel.c_str(), "lep");            leg->AddEntry(ExpPos, ExpLabel.c_str(), "lep");            leg->AddEntry("ErrX", ErrX.c_str(), "l");            leg->AddEntry("ErrY", ErrY.c_str(), "l");            leg->SetEntrySeparation(0.2);            leg->SetTextSize(0.03);            mg->Add(gr);            mg->Add(TruePos);            mg->Add(ExpPos);            string MTitle=Title+"_TrueVsExp";            c1->DrawFrame(nR, nR, pR, pR)->SetTitle(MTitle.c_str());            mg->Draw("p");            leg->Draw();            // Just to Draw Some Plots not all            if((abs(stof(Error[0]))<100 && abs(stof(Error[1]))<100) )            {                this->CombinedTCanvas(c1);            }    }    //Error Estimate for Reconstructed Positions for Sim and Data for Extracted Values    vector<string> ErroEst()    {        Double_t ErrX;        Double_t ErrY;        if(TrueFilePath!="None")            ReadTrueFile();        vector<string> Result;        if(TrueX==0){ TrueX+=1;ExpX+=1; }        if(TrueY==0){ TrueY+=1;ExpY+=1; }        ErrX=abs((ExpX-TrueX)/TrueX)*100;        ErrY=abs((ExpY-TrueY)/TrueY)*100;        Result.push_back(to_string(round(ErrX * 100) / 100.0));        Result.push_back(to_string(round(ErrY * 100) / 100.0));        return Result;    }    //Error Estimate for Reconstructed Positions for Sim and Data for Given values    vector<string> ErroEst(Double_t TrX,Double_t TrY,Double_t ValX,Double_t ValY)    {        Double_t ErrX;        Double_t ErrY;        vector<string> Result;        if(TrX==0){ TrX+=1;ValX+=1; }        if(TrY==0){ TrY+=1;ValY+=1; }        ErrX=abs((ValX-TrX)/TrX)*100;        ErrY=abs((ValY-TrY)/TrY)*100;        Result.push_back(to_string(round(ErrX * 100) / 100.0));        Result.push_back(to_string(round(ErrY * 100) / 100.0));        return Result;    }    vector<string> ErroEst(float TrX,float TrY,float ValX,float ValY)    {        Double_t ErrX;        Double_t ErrY;        vector<string> Result;        if(TrX==0){ TrX+=1;ValX+=1; }        if(TrY==0){ TrY+=1;ValY+=1; }        ErrX=abs((ValX-TrX)/TrX)*100;        ErrY=abs((ValY-TrY)/TrY)*100;        Result.push_back(to_string(round(ErrX * 100) / 100.0));        Result.push_back(to_string(round(ErrY * 100) / 100.0));        return Result;    }    //This Graphs True Values from a specified text file    void ReadTrueFile()    {        string line;        ifstream myfile (TrueFilePath);        vector<string> splitLine;        int count(0);        if (myfile.is_open())        {            getline (myfile,line);            while ( getline (myfile,line) )            {                boost::split(splitLine,line,boost::is_any_of(" "));                if(count==EventID){                    TrueX=stof(splitLine[0]);                    TrueY=stof(splitLine[1]);                    myfile.close();                    break;                }                count++;            }            if (count==0)            {                cout<< "could not find the true position!";                return;            }            myfile.close();        } else {cout << "Unable to open file True Position File"; return;};    }    // Deals of Drawing Circle for Sim and Data  CombinedandSuperImposed function bellow called here    void SaveAndDelete()    {        f->cd();        TotalPEData->Write(0,TObject::kWriteDelete);        TotalPERatiDataSIM->Write(0,TObject::kWriteDelete);        hGoodETime->Write(0,TObject::kWriteDelete);        if(Constrain){            TotalPESim->Write(0,TObject::kWriteDelete);            hNoiseETime->Write(0,TObject::kWriteDelete);            TotalPEData_Noise->Write(0,TObject::kWriteDelete);            TotalPERatiDataSIM_Noise->Write(0,TObject::kWriteDelete);        }        r->cd();        //delete leg,c1,t,mg,gr,TruePos,MeasuredPos,SimulatedPos;        //delete Prob,KolmSmir,SimData;        r->Close();        delete r;        f->cd();        //f->Write();        //delete TotalPEData,TotalPESim,TotalPERatiDataSIM;    }    void DrawSuperImposedCircle(){        gROOT->Reset();        std::cout<<"SuperImposing The Graphs"<<std::endl;        TGraph *TruePos = new TGraph(1);        TGraph *MeasuredPos = new TGraph(1);        TGraph *SimulatedPos= new TGraph(1);        TGraph *gr;        std::vector<unsigned> *DataMeasured=0;        TBranch * b_DataMeasured;        double DataTrueX;        double DataTrueY;        int event;        Long64_t nevents=0;        Int_t n = 360;        Double_t x, y;        string sdev;        string TitleSIPMs;        // Define The Histograms that are needed        std::string SimHistTitle;        SimHistTitle="SimData_"+std::to_string(SimEvents);        SimData    =new TH1F (SimHistTitle.c_str(),"SimData;SIPM id;Activity",NSIPMs, 0.5, NSIPMs+0.5);        SimHistTitle=std::to_string(SimEvents) + "_TotalPE_Data";        TotalPEData = new TH1F (SimHistTitle.c_str(),"TotalPE_Data_Good;TotalPE;Activity",1000,1,0);        SimHistTitle="TotalPE_Data_Noise_"+std::to_string(SimEvents);        TotalPEData_Noise = new TH1F (SimHistTitle.c_str(),"TotalPE_Data_Noise;TotalPE;Activity",1000,1,0);        SimHistTitle="TotalPE_Sim_"+std::to_string(SimEvents);        TotalPESim = new TH1F (SimHistTitle.c_str(),"TotalPE_Sim;TotalPE;Activity",1000,1,0);        SimHistTitle="RatioTotalPE_Good"+std::to_string(SimEvents);        TotalPERatiDataSIM = new TH1F (SimHistTitle.c_str(),"RatioTotalPE_SimAndData_GoodE;TotalPE;Activity",1000,1,0);        SimHistTitle="RatioTotalPE_Noise"+std::to_string(SimEvents);        TotalPERatiDataSIM_Noise = new TH1F (SimHistTitle.c_str(),"RatioTotalPE_SimAndData_NoiseE;TotalPE;Activity",1000,1,0);        SimHistTitle="GoodETime_"+std::to_string(SimEvents);        hGoodETime = new TH1F (SimHistTitle.c_str(),"GoodEvents_Time;Time in ns;Activity",1000,0,200000);        SimHistTitle="NoiseETime_"+std::to_string(SimEvents);        hNoiseETime = new TH1F (SimHistTitle.c_str(),"NoiseEvents_Time;Time in ns;Activity",1000,1,200000);        /*        SimHistTitle="Chi2_Test"+std::to_string(SimEvents);        hChi2Test=new TH1F (SimHistTitle.c_str(),"Chi2_Test;Residual;Activity",1000,1,0);        SimHistTitle="Chi2_Test_Prob"+std::to_string(SimEvents);        hChi2ProbTest=new TH1F (SimHistTitle.c_str(),"NoiseEvents_Time;Time in ns;Activity",1000,1,200000);;        hKolTest=new TH1F (SimHistTitle.c_str(),"NoiseEvents_Time;Time in ns;Activity",1000,1,200000);;        */        for(int i=1;i<=NSIPMs;i++) {            SimData->SetBinContent(i, KSimData[i - 1]);        }        TotalPESim->Fill(SimData->Integral());        /*for (int i=0;i<NSIPMs;i++){            TitleSIPMs="SIPM_"+std::to_string(i+1)+"_Event"+std::to_string(SimEvents);            SIPMs.push_back(new TH1F(TitleSIPMs.c_str(),TitleSIPMs.c_str(),1000,1,0));        }*/        //TrueX=TrueX/10;        //TrueY=TrueY/10;        Double_t pR = Radius + dif;        Double_t nR = -Radius - dif;        vector<string> Error;        vector<string> DataError;        vector<string> SimError;        string ErrX,ErrY,DataErrX,DataErrY;        TMultiGraph *mg= new TMultiGraph();        r=new TFile(RecoDataFilePath.c_str(),"READ");        if(!r)            return;        TTree *t=(TTree*)r->Get("recodata");        if(!t) return;        if(!f) return;        t->SetBranchAddress("event",&event);        t->SetBranchAddress("EstX",&DataExpX);        t->SetBranchAddress("EstY",&DataExpY);        t->SetBranchAddress("TrueX",&DataTrueX);        t->SetBranchAddress("TrueY",&DataTrueY);        t->SetBranchAddress("AnaF",&DataMeasured,&b_DataMeasured);        t->SetBranchAddress("Time",&dTime);        nevents=t->GetEntriesFast();        std::string hTestName="Mean_"+std::to_string(EventID);        Prob=new TH1F("prob","prob",1000,1,0);        KolmSmir=new TH1F("kolsmir","KolSmirTest",1000,1,0);        //std::string FixTitle;        //FixTitle=Title+"SubEvent"+std::to_string(CurrentEvent);        //Title=FixTitle;        TCanvas *c1 = new TCanvas(Title.c_str(),Title.c_str(), 800, 800);        TLegend *leg = new TLegend(0.1,0.75,0.9,0.9);        //Set Graphing parameters        gr = new TGraph(n);        gr->SetMarkerColor(kBlack);        gr->SetMarkerStyle(21);        gr->SetLineWidth(1);        gr->SetMarkerSize(1);        TruePos->SetMarkerColor(kGreen);        TruePos->SetMarkerStyle(20);        TruePos->SetMarkerSize(2);        MeasuredPos->SetMarkerColor(kBlue);        MeasuredPos->SetMarkerStyle(20);        MeasuredPos->SetMarkerSize(2);        SimulatedPos->SetMarkerColor(kRed);        SimulatedPos->SetMarkerStyle(20);        SimulatedPos->SetMarkerSize(2);        Double_t TotalEvents=SimTotalEvents*nevents;        int EventLimiter=999999;        //int EventLimiter=51;        int EventLimiterCount=0;        for(Long64_t i=0;i< nevents;i++){            t->GetEntry(i);            Error.clear();            DataError.clear();            Error=ErroEst();            DataError=ErroEst(DataTrueX,DataTrueY,DataExpX,DataExpY);            CurrentEvent+=1;            ProgressIndicator(TotalEvents,CurrentEvent);            if(DataTrueX==TrueX && DataTrueY==TrueY)            {                //std::cout<<"SX= "<<TrueX<<" SY= " <<TrueY <<" DX= "<<DataTrueX<<" DY= "<<DataTrueY<<std::endl;                ErrX="SimEX= " + (Error[0]) ;                ErrY="SimEY= " + (Error[1])  ;                DataErrX="DatEX= " + (DataError[0])  ;                DataErrY="DatEY= " + (DataError[1])  ;                c1->SetGrid();                for (Int_t i = 0; i < n; i++)                {                    x = Radius * cos(i);                    y = Radius * sin(i);                    gr->SetPoint(i, x, y);                }                TruePos->SetPoint(0,TrueX,TrueY);                MeasuredPos->SetPoint(0,DataExpX, DataExpY);                SimulatedPos->SetPoint(0,ExpX,ExpY);                string TrueLabel;                string ExpLabel;                string DataLabel;                string DataELabel;                string SimELabel;                TrueLabel = "TrueX= " + to_string(TrueX) + " , " + "TrueY= " + to_string(TrueY);                ExpLabel = "SimX= " + to_string(ExpX) + " , " + "SimY= " + to_string(ExpY);                DataLabel = "DataX= " + to_string(DataExpX) + " , " + "DataY= " + to_string(DataExpY);                DataELabel= DataErrX +" , "+ DataErrY;                SimELabel= ErrX +" , "+ ErrY;                leg->SetHeader("Results");                leg->AddEntry(TruePos, TrueLabel.c_str(), "lep");                leg->AddEntry(MeasuredPos, DataLabel.c_str(), "lep");                leg->AddEntry("DataE", DataELabel.c_str(), "l");                leg->AddEntry(SimulatedPos, ExpLabel.c_str(), "lep");                leg->AddEntry("SimE", SimELabel.c_str(), "l");                leg->SetEntrySeparation(0.3);                leg->SetTextSize(0.03);                mg->Add(gr);                mg->Add(TruePos);                mg->Add(MeasuredPos);                mg->Add(SimulatedPos);                string MTitle=Title+"_TrueVsExp";                c1->DrawFrame(nR, nR, pR, pR)->SetTitle(MTitle.c_str());                mg->Draw("p");                leg->Draw();                c1->Update();                // Define Percent Error                fDataErrX=std::stof( DataError[0]);                fDataErrY=std::stof( DataError[1]);                if(this->CombinedandSuperImposed(c1,*DataMeasured))                {                    if (EventLimiterCount>=EventLimiter)                    {                        SaveAndDelete();                        return ;                    }                    EventLimiterCount++;                }                c1->Clear();                leg->Clear();                mg->Clear();                gr->Clear();                TruePos->Clear();                MeasuredPos->Clear();                SimulatedPos->Clear();                CountEvents++;            }            EventID++;        }        SaveAndDelete();        std::cout<<"Done!"<<std::endl;    }    //Compares two unbinned 1D data and simulation distributions for similarity    void KolSmirTest(const Double_t *data,const Double_t * Sim,int DataSize,int SimSize,std::string option="P")    {        KolmSmir->Clear();        KolmSmir->Reset();        Double_t result;        result=TMath::KolmogorovTest(DataSize,data,SimSize,Sim,option.c_str());        std::string KolStitle="KS Test";//+std::to_string(result);        KolmSmir->SetTitle(KolStitle.c_str());        KolmSmir->Fill(result);    }    void chi2TestV(TH1F *h1,TH1F *h2)    {        std::string hName,h2Name,chi2,sEventID=std::to_string(EventID);        //std::cout<<"Before Division"<<std::endl;        //std::cout<<"h1 Integral = "<< h1->Integral()<<" h2 Integral = "<< h2->Integral()<<std::endl;        const Int_t n=NSIPMs;        Double_t residues[n];        Double_t x[n];        Double_t Result;        hName=h1->GetName()+sEventID;        h2Name=h2->GetName()+sEventID;        chi2="chi2test_"+sEventID;        for(Int_t i=0;i<n;i++){            //SIPMs.at(i)->Fill(residues[i]);            x[i]=i+1;        }        Result=h1->Chi2Test(h2,"UU NORM",residues);        //if (Result<1e-300)        //return false;        std::string ChiTitle;        ChiTitle="NormResiduals,Probability= " + std::to_string(Result);        Qv=new TF1("f","TMath::Gaus(x,0,1)",-20,20);        Chi2Residues = new TGraph(n,x,residues);        Chi2Residues->SetMarkerStyle(21);        Chi2Residues->SetMarkerSize(.9);        Chi2Residues->SetTitle(ChiTitle.c_str());        // Create Q-Quantile Plot        QGraph=new TGraphQQ(n,residues,Qv);        QGraph->SetMarkerStyle(20);        QGraph->SetMarkerColor(2);        QGraph->SetMarkerSize(.9);        QGraph->SetTitle("Q-Q plot of Normalized Residuals");        ChiTitle="Probability= " + std::to_string(Result);        Prob->SetTitle(ChiTitle.c_str());        Prob->Fill(Result);        //std::cout<<"Chi2Test is done!"<<std::endl;    }    //Compares two Histograms for similarity    bool chi2Test(TH1F *h1,TH1F *h2)    {        Prob->Clear();        Prob->Reset();        std::string hName,h2Name,chi2,sEventID=std::to_string(EventID);        //std::cout<<"Before Division"<<std::endl;        //std::cout<<"h1 Integral = "<< h1->Integral()<<" h2 Integral = "<< h2->Integral()<<std::endl;        const Int_t n=NSIPMs;        Double_t residues[n];        Double_t x[n];        Double_t Result;        hName=h1->GetName()+sEventID;        h2Name=h2->GetName()+sEventID;        chi2="chi2test_"+sEventID;        for(Int_t i=0;i<n;i++){            //SIPMs.at(i)->Fill(residues[i]);            x[i]=i+1;        }        Result=h1->Chi2Test(h2,"UU NORM",residues);        //if (Result<1e-80)            //return false;        std::string ChiTitle;        ChiTitle="NormResiduals,Probability= " + std::to_string(Result);        Qv=new TF1("f","TMath::Gaus(x,0,1)",-20,20);        Chi2Residues = new TGraph(n,x,residues);        Chi2Residues->SetMarkerStyle(21);        Chi2Residues->SetMarkerSize(.9);        Chi2Residues->SetTitle(ChiTitle.c_str());        // Create Q-Quantile Plot        QGraph=new TGraphQQ(n,residues,Qv);        QGraph->SetMarkerStyle(20);        QGraph->SetMarkerColor(2);        QGraph->SetMarkerSize(.9);        QGraph->SetTitle("Q-Q plot of Normalized Residuals");        ChiTitle="Probability= " + std::to_string(Result);        Prob->SetTitle(ChiTitle.c_str());        Prob->Fill(Result);        //std::cout<<"Chi2Test is done!"<<std::endl;        return true;    }    //This Creates A Canvas to combine Graphs for only single data  set reconstruction    void CombinedTCanvas(TCanvas *c2)    {            string Name=Title+"Combined";        auto *mc1=new TCanvas(Name.c_str(),Name.c_str(),150,10,800,800);        mc1->SetTitle(Name.c_str());        mc1->Divide(2,2,0.01,0.01);        mc1->SetTopMargin(100);        mc1->cd(1);        gPad->SetTickx(2);        gPad->SetTicky(2);        hchi2D->Draw("colz");        mc1->cd(2);        gPad->SetTickx(2);        gPad->SetTicky(2);        hmli2D->Draw("colz");        mc1->cd(3);        gPad->SetTickx(2);        gPad->SetTicky(2);        Measured->GetYaxis()->SetTitleOffset(1.55);        Measured->SetLineColor(2);        Measured->SetLineWidth(4);        Measured->Draw();        mc1->cd(4);        gPad->SetTickx(2);        gPad->SetTicky(2);        c2->DrawClonePad();        gPad->Update();        mc1->cd();        auto *newpad=new TPad("newpad","a transparent pad",1,1,0,0);        newpad->SetFillStyle(4000);        newpad->Draw();        newpad->cd();        string n=FileName;        /*auto *title = new TPaveLabel(0.1,0.96,0.9,1,n.c_str());        title->SetFillColor(16);        title->SetTextFont(42);        title->Draw();         */        TPaveLabel *title = new TPaveLabel(.4,.95,.60,.99,n.c_str(),"brndc");        title->Draw();        gPad->Update();        /*if(SaveImg && Title.find("Fill")!=string::npos){            string ImageName=FilePath+FileName+Name+".jpg";            mc1->Print(ImageName.c_str());        }*/        string ImageName=FilePath+FileName+Name+".jpg";        //mc1->Print(ImageName.c_str());        delete gROOT->FindObject("hframe");        delete gROOT->FindObject("exp");        delete gROOT->FindObject("measured");        //if(SaveFile)            //mc1->Write();    }    // Deals of Creating Combined Graphs for specifically dealing with data and simulation    bool CombinedandSuperImposed(TCanvas *c2, std::vector<unsigned> data)    {        string Name=Title+"SuperImposed_"+std::to_string(EventID);        //std::cout<<"NameOfFile --> "<<Name<<std::endl;        mc1=new TCanvas(Name.c_str(),Name.c_str(),150,10,800,800);        //Defining Histograms        hDataMeasured = new TH1F ("data", "Data;SIPM id;Activity", data.size(), 0.5, data.size()+0.5);        //TestData= new TH1F("testData","Data;SIPM id;Activity", data.size(), 0.5, data.size()+0.5);        //TestSim= new TH1F("testSim","Data;SIPM id;Activity", data.size(), 0.5, data.size()+0.5);        //std::cout<<"Dataentries = "<<data.size()<<std::endl;         Double_t DataCollect[data.size()];         float Simvalu,DataVal;         float TotalSim=0;        //const Double_t *SimDataxx;        //Double_t SimDataxx2[NSIPMs];        std::map<size_t,size_t> ActualData;        std::vector<int>vRealData;        std::vector<int> vSimData;        std::vector<float> PercentError;        Double_t Result;        Double_t Residues[NSIPMs];        std::vector<float>vResidues;        SimDataClone=(TH1F*)SimData->Clone();        for (size_t i=1;i<=data.size();i++){            if(std::find(DeadChannels.begin(),DeadChannels.end(),i-1)==DeadChannels.end())                DataVal = data.at(i - 1);            else                DataVal = 0;                hDataMeasured->SetBinContent(i, DataVal);                //Simvalu=KSimData[i-1];                ActualData.insert(pair<size_t, size_t>(i - 1, DataVal));  //Insert the data                vRealData.push_back((int)DataVal);                vSimData.push_back((int)KSimData[i-1]);                //Simvalu=KSimData[i-1];                DataCollect[i - 1] = DataVal;                TotalSim += DataVal;        }        KData=DataCollect;        Double_t value=0;        //Define Clones        TRatioPlot *tRatioPlot2=new TRatioPlot(hDataMeasured,SimDataClone);        Double_t Norm=hDataMeasured->Integral()/SimDataClone->Integral();        float TotalPEs=hDataMeasured->Integral();        SimReco = {(float) ExpX, (float) ExpY};        vTruePos = {(float) TrueX, (float) TrueY};        DataRecoPos = {(float) DataExpX, (float) DataExpY};        PercentError.push_back(fDataErrX);        PercentError.push_back(fDataErrY);        //Scale HistogramsW        //Double_t Norm=1/SimDataClone->Integral();        SimDataClone->Scale(Norm);        //if(!chi2Test(hDataMeasured,SimDataClone) || TotalSim<=0) {         //if(TotalSim>0) {            //mc1->Write();            //ana->Fill(event,nPixels,R,nPrimaries,*sourcePosXYZ,*sipmToLY,TotalSimLight,SimReco,vTruePos,DataRecoPos);            //KolSmirTest(KData,SimDataClonexx,data.size(),data.size());            // Get the Chi2 and Residues        chi2Test(hDataMeasured,SimDataClone);        Result=hDataMeasured->Chi2Test(SimDataClone,"UU NORM",Residues);        for (float i : Residues)            vResidues.push_back(i);        // Reconstruct Data again        majreco::Reconstructor DataReco(ActualData, PixelTable->GetPixels(), Radius,EventID);        DataReco.DoChi2(ConfigUnpanilized);        ana->Fill(CountEvents, nPixels,Radius, nPrimaries, *sourcePosXYZ, *sipmToLY, TotalSimLight, SimReco,vTruePos, DataRecoPos,dTime,TotalPEs,SimData->Integral(),Result,vResidues,vRealData,vSimData,PercentError,DataReco.Chi2(),DataReco.Chi2ID(),DataReco.Chi2Vertex(),fSimReco->Chi2(),fSimReco->Chi2ID(),fSimReco->Chi2Vertex());        if(TotalSim<=0 or Skip){            delete mc1, c2,tRatioPlot2;            DeleteAll();            return true;            //return true;        }/*else            {                delete mc1, c2,tRatioPlot2;                DeleteAll();                //return false;                return false;            }*/        DataGausFit= DataReco.getGaus();        SimDataClone->GetYaxis()->SetTitleOffset(1.55);        SimDataClone->SetLineColor(kRed);        SimDataClone->SetMarkerColor(kRed);        SimDataClone->SetMarkerStyle(20);        SimDataClone->SetLineWidth(3);        SimDataClone->SetMarkerSize(1);        SimDataClone->Scale(hDataMeasured->Integral()/SimDataClone->Integral());        hDataMeasured->GetYaxis()->SetTitleOffset(1.55);        hDataMeasured->SetLineColor(kBlue);        hDataMeasured->SetLineWidth(3);        //Double_t Chi2Result=DataReco.Chi2Image()->Chi2Test(hchi2D,"UU");        Double_t KolmvResult=DataReco.Chi2Image()->KolmogorovTest(hchi2D);        //Double_t AndersonDarlingResult=hDataMeasured->AndersonDarlingTest(SimDataClone);        /*if(!(KolmvResult<0.5) ||  TotalSim<=0) {            //mc1->Write();            //KolSmirTest(KData,SimDataClonexx,data.size(),data.size());            delete mc1, c2,tRatioPlot2;            DeleteAll();            return false;        }*/        //chi2Test(hDataMeasured,SimDataClone);        mc1->SetTitle(Name.c_str());        mc1->Divide(3,3,0.01,0.01);        mc1->SetTopMargin(100);        mc1->cd(1);        gPad->SetTickx(2);        gPad->SetTicky(2);        DataReco.Chi2Image()->SetTitle("DataChi");        DataReco.Chi2Image()->Draw("colz");        mc1->cd(2);        gPad->SetTickx(2);        gPad->SetTicky(2);        DataReco.MLImage()->SetTitle("DataMLI");        //DataReco.MLImage()->SetTitle(std::to_string(Chi2Result).c_str());        DataReco.MLImage()->Draw("colz");        mc1->cd(3);        gPad->SetTickx(2);        gPad->SetTicky(2);        c2->DrawClonePad();        mc1->cd(4);        gPad->SetTickx(2);        gPad->SetTicky(2);        hchi2D->Draw("colz");        std::string Kolmp="Kolm_P= " + std::to_string(KolmvResult);        hchi2D->SetTitle(Kolmp.c_str());        gPad->Update();        mc1->cd(5);        hmli2D->SetTitle("SimMLI");        hmli2D->Draw("colz");        mc1->cd(6);        tRatioPlot2->Draw();        mc1->cd(7);        QGraph->Draw("AP");        mc1->cd(8);        hDataMeasured->Draw("HIST");        SimDataClone->Draw("HISTSAME");        mc1->cd(9);        Chi2Residues->Draw("APL");        /*mc1->cd(10);        DataGausFit->SetTitle("DataGausFit");        DataGausFit->Draw();        mc1->cd(11);        SimGausFit->SetTitle("SimGausFit");        SimGausFit->Draw();        */        /*mc1->cd(10);        tRatioPlot->Draw();        mc1->cd(11);        SimDataClone->Draw("HIST");        //hDataMeasured->DrawNormalized("SAME",1);        hDataMeasured->Draw("SAME");        */         mc1->cd();        auto *newpad=new TPad("newpad","a transparent pad",1,1,0,0);        newpad->SetFillStyle(4000);        newpad->Draw();        newpad->cd();        string n=FileName;        /*auto *title = new TPaveLabel(0.1,0.96,0.9,1,n.c_str());        title->SetFillColor(16);        title->SetTextFont(42);        title->Draw();        */        TPaveLabel *title = new TPaveLabel(0.31152,0.972581,0.445969,0.998433,n.c_str(),"brndc");        title->Draw();        gPad->Update();        /*if(SaveImg && Title.find("Fill")!=string::npos){            string ImageName=FilePath+FileName+Name+".jpg";            mc1->Print(ImageName.c_str());        }*/        if(SaveFile){            string ImageName=FilePath+FileName+Name+".jpg";            mc1->Print(ImageName.c_str());        }        /*SimDataClone->Write();        hDataMeasured->Write();        Measured->Write();        */        //if(SaveFile)        DataEvents++;        f->cd();        if(CDraw)            mc1->Write(0,TObject::kWriteDelete);        r->cd();        DataReco.Clean();        ActualData.clear();        //delete newpad,title;        //delete tRatioPlot;        delete mc1,c2;        delete tRatioPlot2;        DeleteAll();        return true;    }    // Delete Histograms and anything needed to be deleted    void DeleteAll()    {        if(hDataMeasured!= nullptr)            delete hDataMeasured;        //if(SimDataClone!= nullptr)            //delete SimDataClone;        if(Qv!= nullptr)            delete Qv;        if(QGraph!= nullptr)            delete QGraph;        if(Chi2Residues!= nullptr)            delete Chi2Residues;        KData= nullptr;        Chi2Residues=nullptr;        Qv= nullptr;        QGraph = nullptr;        SimDataClone=nullptr;        hDataMeasured= nullptr;        KolmSmir->Clear();        fDataErrX=-99999;        fDataErrY=-99999;        delete gROOT->FindObject("hframe");    }    // To Keep Track Process    void ProgressIndicator(Long64_t NumberOfEvents,Long64_t CurrentEvent)    {        if(CurrentEvent<NumberOfEvents)        {            std::cout<<"Progress->> " <<((float)CurrentEvent/(float)NumberOfEvents)*100 << " % Done\r";            std::cout.flush();        }else {            std::cout<<"Done!\r";            std::cout.flush();        }    }    // For Obtainning DarkCounts    void GetDarkFiles(string FilePath,vector<string>&FileNames)    {        string line;        cout<<"ThePath  : " << FilePath <<endl;        ifstream myfile (FilePath);        unsigned int count(0);        cout<< "Getting the file Names"<<endl;        if (myfile.is_open())        {            while ( getline (myfile,line) )            {                FileNames.push_back(line);                count++;            }            if (count==0)            {                cout<< "could not find any files!";                return;            } else cout << "Total of " << count << " are obtained" << endl;            myfile.close();        } else {cout << "Unable to open file "; return;};    }    Double_t Chi2(Double_t *Data,Double_t *Sim,int NSIPMs)    {         int DF=NSIPMs-1;         Double_t ChiSqrtT=0;         for(int i=1;i<=NSIPMs;i++)         {             ChiSqrtT+=((Data[i]-Sim[i])*(Data[i]-Sim[i]))/Sim[i];         }         return ChiSqrtT;    }    //---- Function is used for averaging the backgrounds ---    void DarkCountAveraging(string Path,string NewFileName,string TxtFileList){        struct TTreeHelp ahtr;        struct TTreeHelp aAvr;        struct TTreeHelp *AverAnaData;        struct TTreeHelp *htr;        htr=&ahtr;        AverAnaData=&aAvr;        string NewAnaPath=Path + NewFileName;        string Files=Path + TxtFileList; // File name and path that contains the dark counts        string DarkPath;        AverAnaData->eventID=0;        Int_t NSIPMs=64; // Number of SIPMs        vector<string> FileNames;        GetDarkFiles(Files,FileNames); // Gets the file names        for (auto Name : FileNames){            DarkPath= Path + Name;            cout << "Openning the file " << Name<<endl;            auto fDark = TFile::Open(DarkPath.c_str(),"READ");            if (!fDark) return;            TTree * dt;            fDark->GetObject("ana",dt);            if(!dt) return;            dt->SetBranchAddress("TTreeHelp",&htr);            Long64_t nentries = dt->GetEntries();            if (dt->GetEntries()==0) // Checks if there is any event            {                cout<<"Entries are 0"<<endl;                return;            }            for (Long64_t jentry=0; jentry<nentries; jentry++) {                dt->GetEvent(jentry);                cout<<"Working on Event " << jentry<<endl;                AverAnaData->eventID+=jentry;                for (unsigned int i = 0; i < NSIPMs; i++) {                    if(AverAnaData->DiffTime.size()<NSIPMs)                    {                        AverAnaData->ActualCounts.insert(i+AverAnaData->ActualCounts.begin(), (htr->ActualCounts.at(i)));                        AverAnaData->FilteredCounts.insert(i+AverAnaData->FilteredCounts.begin(),(htr->FilteredCounts.at(i)));                        AverAnaData->AnaCounts.insert(i+AverAnaData->AnaCounts.begin(), (htr->AnaCounts.at(i)));                        AverAnaData->NPairCounts.insert(i+AverAnaData->NPairCounts.begin(),(htr->NPairCounts.at(i)));                        AverAnaData->DiffTime.insert(i+AverAnaData->DiffTime.begin(),(htr->DiffTime.at(i)));                    }else{                        AverAnaData->ActualCounts.at(i)+=htr->ActualCounts.at(i);                        AverAnaData->FilteredCounts.at(i)+=htr->FilteredCounts.at(i);                        AverAnaData->AnaCounts.at(i)+=htr->AnaCounts.at(i);                        AverAnaData->NPairCounts.at(i)+=htr->NPairCounts.at(i);                        AverAnaData->DiffTime.at(i)+=htr->DiffTime.at(i);                    }                } // Loop over each SIPM            } // Loop over each events            fDark->Close();            cout<<"Done -->>  " + Name << endl;        } // Loop over each File        unsigned int NofFiles= FileNames.size();        for (unsigned i = 0; i < NSIPMs; i++) {            AverAnaData->ActualCounts.at(i)=AverAnaData->ActualCounts.at(i)/NofFiles;            AverAnaData->FilteredCounts.at(i)=AverAnaData->FilteredCounts.at(i)/NofFiles;            AverAnaData->AnaCounts.at(i)=AverAnaData->AnaCounts.at(i)/NofFiles;            AverAnaData->NPairCounts.at(i)=AverAnaData->NPairCounts.at(i)/NofFiles;            AverAnaData->DiffTime.at(i)=AverAnaData->DiffTime.at(i)/NofFiles;        }        auto f  = TFile::Open(NewAnaPath.c_str(),"RECREATE"); // Open the new file        TTree* Avrt = (TTree*)f->Get("ana");        if (!Avrt)        {            Avrt = new TTree("ana", "ana");            Avrt->Branch("TTreeHelp",&AverAnaData);        }        else            Avrt->SetBranchAddress("TTreeHelp", &AverAnaData);        Avrt->Fill();        Avrt->Write(Avrt->GetName(), TObject::kWriteDelete);        Avrt->Reset();        f->Close();        cout<<"Writing to file is Done"<<endl;    }    //Deleting and Reseting Some Variables    void GetSuperImposedCircle(std::vector<unsigned>fRealdata,std::vector<unsigned>fsimData,float fDataTrueX,float fDataTrueY,float fSimTrueX,float fSimTrueY,int Event){         gROOT->Reset();        std::cout<<"SuperImposing The Graphs"<<std::endl;        if(fDataTrueX!=fSimTrueX && fDataTrueY!=fSimTrueY) {std::cout<<"Positions are not matching"<<std::endl; return;}        // Define some usefull variables here        TGraph *TruePos = new TGraph(1);        TGraph *MeasuredPos = new TGraph(1);        TGraph *SimulatedPos= new TGraph(1);        TGraph *gr;        std::vector<unsigned> *DataMeasured=0;        float fDataExpX;        float fDataExpY;        float fSimExpX;        float fSimExpY;        hDataMeasured = new TH1F ("data", "Data;SIPM id;Activity", fRealdata.size(), 0.5, fRealdata.size()+0.5);        SimData = new TH1F ("Simdata", "SimData;SIPM id;Activity", fsimData.size(), 0.5, fsimData.size()+0.5);        TBranch * b_DataMeasured;        int event;        Long64_t nevents=0;        Int_t n = 360;        Double_t x, y;        string sdev;        string TitleSIPMs;        std::map<size_t,size_t> fActualData;        std::map<size_t,size_t> fSimData;        unsigned DataVal,SimDataVal;        // Loop over the data to do reconstruction        unsigned TotalLight=0;        for (size_t i=1;i<=fRealdata.size();i++){            if(std::find(DeadChannels.begin(),DeadChannels.end(),i-1)==DeadChannels.end()){                DataVal = fRealdata.at(i - 1);                SimDataVal = fsimData.at(i-1);            }            else {                DataVal = 0;                SimDataVal =0;            }            TotalLight+=DataVal;            hDataMeasured->SetBinContent(i, DataVal);            SimData->SetBinContent(i, SimDataVal);            fActualData.insert(pair<size_t, size_t>(i - 1, DataVal));  //Insert the data            fSimData.insert(pair<size_t, size_t>(i - 1, SimDataVal));  //Insert the simdata        }            //Get the ChiSquares            majreco::Reconstructor DataReco(fActualData, PixelTable->GetPixels(), Radius,EventID);            DataReco.DoChi2(ConfigUnpanilized);            DataGausFit= DataReco.getGaus();            fDataExpX=DataReco.X();            fDataExpY=DataReco.Y();            majreco::Reconstructor SimReco(fSimData, PixelTable->GetPixels(), Radius,EventID);            SimReco.DoChi2(ConfigUnpanilized);            SimGausFit= DataReco.getGaus();            fSimExpX=SimReco.X();            fSimExpY=SimReco.Y();            Double_t pR = Radius + dif;            Double_t nR = -Radius - dif;            vector<string> Error;            vector<string> DataError;            vector<string> SimError;            string ErrX,ErrY,DataErrX,DataErrY;            TMultiGraph *mg= new TMultiGraph();            std::string hTestName="Mean_"+std::to_string(EventID);            Prob=new TH1F("prob","prob",1000,1,0);            KolmSmir=new TH1F("kolsmir","KolSmirTest",1000,1,0);            //std::string FixTitle;            //FixTitle=Title+"SubEvent"+std::to_string(CurrentEvent);            //Title=FixTitle;            TCanvas *c1 = new TCanvas(Title.c_str(),Title.c_str(), 800, 800);            TLegend *leg = new TLegend(0.1,0.75,0.9,0.9);            //Set Graphing parameters            gr = new TGraph(n);            gr->SetMarkerColor(kBlack);            gr->SetMarkerStyle(21);            gr->SetLineWidth(1);            gr->SetMarkerSize(1);            TruePos->SetMarkerColor(kGreen);            TruePos->SetMarkerStyle(20);            TruePos->SetMarkerSize(2);            MeasuredPos->SetMarkerColor(kBlue);            MeasuredPos->SetMarkerStyle(20);            MeasuredPos->SetMarkerSize(2);            SimulatedPos->SetMarkerColor(kRed);            SimulatedPos->SetMarkerStyle(20);            SimulatedPos->SetMarkerSize(2);            Double_t TotalEvents=SimTotalEvents*nevents;            Error.clear();            DataError.clear();            Error=ErroEst(fSimTrueX,fSimTrueY,fSimExpX,fSimExpY);            DataError=ErroEst(fDataTrueX,fDataTrueY,fDataExpX,fDataExpY);                //std::cout<<"SX= "<<TrueX<<" SY= " <<TrueY <<" DX= "<<DataTrueX<<" DY= "<<DataTrueY<<std::endl;                ErrX="SimEX= " + (Error[0]) ;                ErrY="SimEY= " + (Error[1])  ;                DataErrX="DatEX= " + (DataError[0])  ;                DataErrY="DatEY= " + (DataError[1])  ;                c1->SetGrid();                for (Int_t i = 0; i < n; i++)                {                    x = Radius * cos(i);                    y = Radius * sin(i);                    gr->SetPoint(i, x, y);                }                TruePos->SetPoint(0,fDataTrueX,fDataTrueX);                MeasuredPos->SetPoint(0,fDataExpX, fDataExpY);                SimulatedPos->SetPoint(0,fSimExpY,fSimExpX);                string TrueLabel;                string ExpLabel;                string DataLabel;                string DataELabel;                string SimELabel;                TrueLabel = "TrueX= " + to_string(fDataTrueX) + " , " + "TrueY= " + to_string(fDataTrueY);                ExpLabel = "SimX= " + to_string(fSimExpX) + " , " + "SimY= " + to_string(fSimExpY);                DataLabel = "DataX= " + to_string(fDataExpX) + " , " + "DataY= " + to_string(fDataExpY);                DataELabel= DataErrX +" , "+ DataErrY;                SimELabel= ErrX +" , "+ ErrY;                leg->SetHeader("Results");                leg->AddEntry(TruePos, TrueLabel.c_str(), "lep");                leg->AddEntry(MeasuredPos, DataLabel.c_str(), "lep");                leg->AddEntry("DataE", DataELabel.c_str(), "l");                leg->AddEntry(SimulatedPos, ExpLabel.c_str(), "lep");                leg->AddEntry("SimE", SimELabel.c_str(), "l");                leg->SetEntrySeparation(0.3);                leg->SetTextSize(0.03);                mg->Add(gr);                mg->Add(TruePos);                mg->Add(MeasuredPos);                mg->Add(SimulatedPos);                string MTitle=Title+"_TrueVsExp";                c1->DrawFrame(nR, nR, pR, pR)->SetTitle(MTitle.c_str());                mg->Draw("p");                leg->Draw();                c1->Update();                // Define Percent Error                fDataErrX=std::stof( DataError[0]);                fDataErrY=std::stof( DataError[1]);    //////////////////////////////////////////                ///  Combine Everyhing  /////                ////////////////////////////                SimDataClone = (TH1F*) SimData->Clone();            TRatioPlot *tRatioPlot2=new TRatioPlot(hDataMeasured,SimDataClone);            Double_t Norm=hDataMeasured->Integral()/SimDataClone->Integral();            float TotalPEs=hDataMeasured->Integral();            SimDataClone->Scale(Norm);            chi2Test(hDataMeasured,SimDataClone);            Double_t  Result;            Double_t  *Residues;            std::vector<float> vResidues;            Result=hDataMeasured->Chi2Test(SimDataClone,"UU NORM",Residues);            if(TotalLight<=0 or Skip){                delete mc1, c1,tRatioPlot2;                DeleteAll();                return;            }            SimDataClone->GetYaxis()->SetTitleOffset(1.55);            SimDataClone->SetLineColor(kRed);            SimDataClone->SetMarkerColor(kRed);            SimDataClone->SetMarkerStyle(20);            SimDataClone->SetLineWidth(3);            SimDataClone->SetMarkerSize(1);            SimDataClone->Scale(hDataMeasured->Integral()/SimDataClone->Integral());            hDataMeasured->GetYaxis()->SetTitleOffset(1.55);            hDataMeasured->SetLineColor(kBlue);            hDataMeasured->SetLineWidth(3);            Double_t KolmvResult=DataReco.Chi2Image()->KolmogorovTest(hchi2D);            std::string Name="SuperImposed_"+std::to_string(Event);            mc1->SetTitle(Name.c_str());            mc1->Divide(3,3,0.01,0.01);            mc1->SetTopMargin(100);            mc1->cd(1);            gPad->SetTickx(2);            gPad->SetTicky(2);            DataReco.Chi2Image()->SetTitle("DataChi");            DataReco.Chi2Image()->Draw("colz");            mc1->cd(2);            gPad->SetTickx(2);            gPad->SetTicky(2);            DataReco.MLImage()->SetTitle("DataMLI");            DataReco.MLImage()->Draw("colz");            mc1->cd(3);            gPad->SetTickx(2);            gPad->SetTicky(2);            c1->DrawClonePad();            mc1->cd(4);            gPad->SetTickx(2);            gPad->SetTicky(2);            SimReco.Chi2Image()->SetTitle("SimChi");            SimReco.Chi2Image()->Draw("colz");            gPad->Update();            mc1->cd(5);            SimReco.MLImage()->SetTitle("SimMLI");            SimReco.MLImage()->Draw("colz");            mc1->cd(6);            tRatioPlot2->Draw();            mc1->cd(7);            QGraph->Draw("AP");            mc1->cd(8);            hDataMeasured->Draw("HIST");            SimDataClone->Draw("HISTSAME");            mc1->cd(9);            Chi2Residues->Draw("APL");            mc1->cd();            auto *newpad=new TPad("newpad","a transparent pad",1,1,0,0);            newpad->SetFillStyle(4000);            newpad->Draw();            newpad->cd();            string np=FileName;            TPaveLabel *title = new TPaveLabel(0.31152,0.972581,0.445969,0.998433,np.c_str(),"brndc");            title->Draw();            gPad->Update();            if(SaveFile){                string ImageName="SuperImposed_"+std::to_string(Event)+".jpg";                mc1->Print(ImageName.c_str());            }            DataEvents++;            f->cd();            if(CDraw)                mc1->Write(0,TObject::kWriteDelete);            r->cd();            delete mc1,c1;            delete tRatioPlot2;            DeleteAll();                /////////////////////////////                ///  Combine Everyhing  /////    ////////////////////////////////////////////     }};}#endif //ANA_CFUNCTIONS_H